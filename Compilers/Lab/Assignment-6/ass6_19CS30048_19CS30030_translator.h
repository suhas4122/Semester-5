#ifndef ASS6_19CS30048_19CS30030_TRANSLATOR_H
#define ASS6_19CS30048_19CS30030_TRANSLATOR_H

#include <stdio.h>
#include <vector>
#include <cstdlib>
#include <string>
#include <set>
#include <map>
#include <stack>
using namespace std;

extern map<int,int> mp_set;
extern int size_int;
extern int size_double;
extern int size_pointer;
extern int size_char;
extern int size_bool;
extern stack<string> params_stack;
extern stack<int> types_stack;
extern stack<int> offset_stack;
extern stack<int> ptrarr_stack;
extern vector<string> strings_label;

/*
    Class Definitions
    ------------------
    class type_n;
	class expresn;
	class quad; 
	class symdata; 
	class symtab;
	class quad_arr; 
	class funct;
	class Array;
*/

class type_n;
class expresn;
class quad; 
class symdata; 
class symtab;
class quad_arr; 
class funct;
class Array;

/*
	Struct Definitions
	------------------
	struct decStr;
	struct idStr;
	struct expresn;
	struct arglistStr;
*/

struct decStr;
struct idStr;
struct expresn;
struct arglistStr;

extern type_n *glob_type;
extern int glob_width; 
extern int next_instr; 			// Next instr for use in quads and in different function like backpatch
extern int temp_count; 			// Count of the temporary varibles to name the new temporary variable
extern symtab *glob_st;			// Global symbol table pointer
extern symtab *curr_st; 		// Current Symbol table pointer
extern quad_arr glob_quad; 		// To store all the quads that will be generated by the grammar


typedef struct list{
	int index;
	struct list *next;
}list;

/*
	Enum Definitions
	------------------
	enum types;
	enum opcodes;
*/

/*
	enum types
	Lists all the types the tinyC compiler understands
	------------------
*/

enum types{
	tp_void=0,
	tp_bool,
	tp_char,
	tp_int,
	tp_double,
	tp_ptr,
	tp_arr,
	tp_func
};

/*
	enum opcode
	Lists all the opcodes that are possible.These will be used in the translator
	------------------
*/
enum opcode{

	// Binary Assignment Operator
	Q_PLUS=1,Q_MINUS,Q_MULT,Q_DIVIDE,Q_MODULO,Q_LEFT_OP,Q_RIGHT_OP,
	Q_XOR,Q_AND,Q_OR,Q_LOG_AND,Q_LOG_OR,Q_LESS,Q_LESS_OR_EQUAL,
	Q_GREATER_OR_EQUAL,Q_GREATER,Q_EQUAL,Q_NOT_EQUAL,

	// Unary Assignment Operator
	Q_UNARY_MINUS,Q_UNARY_PLUS,Q_COMPLEMENT,Q_NOT,

	// Copy Assignment
	Q_ASSIGN,
	Q_GOTO,

	// Conditional Jump
	Q_IF_EQUAL,Q_IF_NOT_EQUAL,Q_IF_EXPRESSION,Q_IF_NOT_EXPRESSION,
	Q_IF_LESS,Q_IF_GREATER,Q_IF_LESS_OR_EQUAL,Q_IF_GREATER_OR_EQUAL,

	// Type Conversions
	Q_CHAR2INT,Q_CHAR2DOUBLE,Q_INT2CHAR,Q_DOUBLE2CHAR,Q_INT2DOUBLE,Q_DOUBLE2INT,


	// Procedure Call
	Q_PARAM,Q_CALL,Q_RETURN,

	// Pointer Assignment Operator
	Q_LDEREF,Q_RDEREF,
	Q_ADDR,

	// Array Indexing
	Q_RINDEX,
	Q_LINDEX,

};

/*
    The union baseType defines the basic types that can exist in the program. It stores
    the initialized value of the type inside the symbol table
*/

union basic_val{
	int int_val;
	double double_val;
	char char_val;
};

class type_n{
public:
	int size;    								// To save the size of the type
	types basetp; 								// To save the basic type of the elemnt
	type_n *next; 								// To save next type_n type for arrays
	type_n(types t,int sz=1, type_n *n=NULL); 	// Constuctor
	int getSize(); 								// Returns the size
	types getBasetp();							// Return Base type
	void printSize(); 							// To print the size
	void print(); 
};

type_n *CopyType(type_n *t);

class Array
{
public:

	// Stores the Array base and the variable containing Array offset
	string base_arr;
	types tp;
	
	// Initiates Array name, offset and Array type 
	Array(string s,int sz,types t);
	
	// Stores Array dimensions
	vector<int> dims;

	// Size of base type
	int bsize;

	// Number of dimensions
	int dimension_size;

	// Adds an Array index for Array accessing 
	void addindex(int i);

};



// To store details of functions, its parameters and return type 
class funct
{
public:
	// Parameter type list 
	vector<types> typelist;

	// Return type 
	type_n *rettype;

	funct(vector<types> tpls);

	// Prints details in suitable format
	void print();
};


// Class which will be used as building element for symbol table
class symdata{
public:
	string name;
	int size; 
	int offset;
	basic_val i_val;		// To store the initialized value for an element stored at symbol table
	type_n *tp_n;			// For storing the type of element
	symtab *nest_tab; 		// To store the pointer to the symbol table to which the current element belongs to
	Array *arr;				// To store the pointer to an Array if its an Array type
	funct *fun;				// To store the pointer to a function if its an function
	void createarray();
	string var_type;		// To store whether the varaible is "null=0" "local=1" "param=2" "func=3" "ret=4" "temporary=5"
	bool isInitialized; 	// If the value of element is initialized or not
	bool isFunction; 		// To know whether the current element is function like function pointer
	bool isArray; 			// To know whether the current element is ab Array it helps if we have been in grammar tree
	symdata(string n=""); 	// Name is initialized to null that will be used for naming temporary variables
	bool ispresent;
	bool isdone;
	bool isptrarr;
	bool isGlobal;
};	

class symtab{
public:
	string name;					// Name of the symbol
	int offset;						// Final offset of this symbol table that will be used in the update function
	int start_quad;
	int end_quad;
	vector<symdata*> symbol_tab; 	// Maintaining a list of symbol tables
	symtab();  						// Constructor
	~symtab(); 						// Destructor
	symdata* lookup(string n);		// Lookup function searches the variable with name. If the variable is present then returns its pointer location else creates a new entry with its name and returns that pointer
	symdata* lookup_2(string n);	// To handle global variables
	symdata* search(string n); 		// It searches for the variable and returns the oiter to it if present
	symdata* gentemp(type_n *type); // Gentemp creates a new element in the symbol table with the type provided at the time of constructing
	void update(symdata *loc, type_n *type, basic_val initval, symtab *next = NULL);//
	void print();
	int no_params;
	void mark_labels();
	void function_prologue(FILE *fp,int count);
	void global_variables(FILE *fp);
	void gen_internal_code(FILE *fp,int ret_count);
	int function_call(FILE *fp);
	void function_epilogue(FILE *fp,int count,int ret_count);
	string assign_reg(int type_of,int no);
	void assign_offset();
	void function_restore(FILE *fp);
	int findg(string n);
};

/*
	struct expresn
    Stores an expresn along with the type it evaluates to, symbol table it is in etc
    ------------------
    args: vector<expresn *> -> Vector of expressions
*/

struct expresn{
	symdata* loc;
	type_n* type;
	list* truelist;
	list* falselist;
	bool isPointer;
	bool isArray;
	bool isString;
	int ind_str;
	symdata *arr;
	symdata *poss_array;
};

list* makelist(int i);  		// Creates new list with only i in it 
list* merge(list *l1,list *l2); // Concatenate two lists and return pointer to the merged list
void backpatch(list *l,int i);  // To fill the dangling list of goto's l1 to i
void conv2Bool(expresn *e); 	// To convert the given exprssion type to bool mostly used in relational operator
void typecheck(expresn *e1, expresn *e2, bool isAss = false);
void print_list(list *root);

// Struct for declaration grammar
struct decStr
{
	type_n *type;						// Type of the current declaration
	int width;							// Width of the variable
};


/*
	class quad
	quad(opcode op, string _arg1, string _arg2, string result)
	------------------
	Member Variables:
		op: string         -> Operator
		arg1: string   	   -> First argument
		arg2: string       -> Second argument
		result: string     -> Result of the TAC
	Member Methods:
		print_arg: void    -> Print a quad
	------------------
*/
class quad{
public:
	string arg1,result,arg2; 		
	opcode op;
	void print_arg();
	quad(opcode, string, string, string); 
};

/*
	struct argList
    Stores a list of all arguments
    ------------------
    args: vector<expression *> -> A vector used to store the locations of all seen arguments
*/

struct arglistStr
{
	vector<expresn*> *arguments;	
};

/*
	struct identifier
    Stores an identifier
    ------------------
    name: string*     -> Name of the identifier
    loc: symdata*     -> Pointer to the symboltable
*/

struct idStr
{
	symdata *loc;					
	string *name;					
};

struct strstr{
	type_n lop;
	string name;
};

/*
	class quad_arr
	------------------
	Member Variables:
		arr: vector<quad>   -> Vector of all quads
	Member Methods:
		print: void         -> Print the quad array
	------------------
*/

class quad_arr{
public:
	vector<quad> arr;				// To store the list of quads
	quad_arr();
	void emit(opcode opc, string arg1="", string arg2="", string result=""); 	// Emit used for operations with 3 inputs
	void emit(opcode opc, int val, string operand="");  						// Emit for assignment of integer
	void emit(opcode opc, double val, string operand=""); 						// Emit for assignment of double
	void emit(opcode opc, char val, string operand=""); 						// Emit for assignment of char
	void emit2(opcode opc,string arg1="", string arg2="", string result="");
	void print(); 					// Print all the quads
};

#endif
